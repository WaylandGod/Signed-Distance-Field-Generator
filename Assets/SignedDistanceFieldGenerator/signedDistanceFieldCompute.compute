//
// Copyright Â© Daniel Shervheim, 2019
// www.danielshervheim.com
//

#pragma kernel CSMain

struct Triangle {
	float3 a, b, c, normal;
};

RWTexture3D<float> voxels;
int textureDimension;
float unitsPerVoxel;

RWStructuredBuffer<Triangle> triangleBuffer;
int triangleCount;
float boundingBoxDimension;



// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm
float dot2(float3 v) {
	return dot(v,v);
}
float udTriangle(float3 p, float3 a, float3 b, float3 c) {
    float3 ba = b - a;
    float3 pa = p - a;
    
    float3 cb = c - b;
    float3 pb = p - b;
    
    float3 ac = a - c;
    float3 pc = p - c;
    
    float3 nor = cross(ba, ac);
    return sqrt(
    (sign(dot(cross(ba,nor),pa)) +
     sign(dot(cross(cb,nor),pb)) +
     sign(dot(cross(ac,nor),pc))<2.0)
     ?
     min( min(
     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),
     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),
     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )
     :
     dot(nor,pa)*dot(nor,pa)/dot2(nor));
}

int intersects (float3 rayOrigin, float3 rayVector, float3 v1, float3 v2, float3 v3) {
	const float EPSILON = 0.0000001; // 0.0000001;
	float3 edge1, edge2, h, s, q;
	float det, invDet, u, v;
	edge1 = v2-v1;
	edge2 = v3-v1;

	h = cross(rayVector, edge2);
	det = dot(edge1, h);
	if (abs(det) < EPSILON) {
		return 0;  // ray is parallel to triangle or hit the back face
	}

	invDet = 1.0/det;
	
	s = rayOrigin - v1;
	u = invDet * dot(s, h);
	if (u < 0.0 || u > 1.0) {
		return 0;
	}

	q = cross(s, edge1);
	v = invDet * dot(rayVector, q);
	if (v < 0.0 || u+v > 1.0) {
		return 0;
	}

	// at this stage we can compute t to find where the intersection point is on the line
	float t = invDet * dot(edge2, q);
	if (t > EPSILON) {
		// ray intersection
		return 1;
	}
	else {
		// line intersection, but not ray
		return 0;
	}
}

[numthreads(8,8,8)]
void CSMain (uint3 id : SV_DispatchThreadID) {

	float3 pos = (float3)id;  // 0:textureDimension-1
	pos /= (float)(textureDimension-1.0);  // 0:1
	pos *= boundingBoxDimension;  // 0:boundingBoxDimension
	pos -= (boundingBoxDimension/2.0);  // -bbd/2:bbd/2

	// find the index of the nearest triangle
	uint intersectionCounter = 0;
	int minI = 0;
	for (int i = 0; i < triangleCount; i++) {
		float minDist = udTriangle(pos, triangleBuffer[minI].a, triangleBuffer[minI].b, triangleBuffer[minI].c);

		float3 ia = triangleBuffer[i].a;
		float3 ib = triangleBuffer[i].b;
		float3 ic = triangleBuffer[i].c;

		float curDist = udTriangle(pos, ia, ib, ic);
		if (curDist < minDist) {
			minI = i;
		}

		float3 com = (ia+ib+ic)/3.0;
		float3 dir = normalize(pos-com)*textureDimension*textureDimension;
		intersectionCounter += intersects(pos, float3(0,1,0), ia, ib, ic);
	}

	/*
	float3 U = triangleBuffer[minI].b - triangleBuffer[minI].a;
	float3 V = triangleBuffer[minI].c - triangleBuffer[minI].a;
	float3 N = cross(U, V);
	float3 trianglePos = (triangleBuffer[minI].a + triangleBuffer[minI].b + triangleBuffer[minI].c)/3.0;
	float s = sign(dot(N, pos-trianglePos));
	*/

	float s = intersectionCounter%2==0 ? 1 : -1;

	float distance = udTriangle(pos, triangleBuffer[minI].a, triangleBuffer[minI].b, triangleBuffer[minI].c);
	voxels[id] = sqrt(distance) * s;
}